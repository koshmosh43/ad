/** <<Typesetter> function dependency: >.init **/

troikaDefine(
function(){return (
function(t,e){const i=1/0,n=/[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/,r="[^\\S\\u00A0]",o=new RegExp(`${r}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);function a({text:a="",font:u,lang:d,sdfGlyphSize:p=64,fontSize:m=400,fontWeight:g=1,fontStyle:f="normal",letterSpacing:M=0,lineHeight:y="normal",maxWidth:v=i,direction:b,textAlign:A="left",textIndent:P=0,whiteSpace:x="normal",overflowWrap:S="normal",anchorX:C=0,anchorY:_=0,metricsOnly:w=!1,unicodeFontsURL:T,preResolvedFonts:L=null,includeCaretPositions:D=!1,chunkedBoundsSize:I=8192,colorRanges:O=null},E){const B=h(),z={fontLoad:0,typesetting:0};a.indexOf("\r")>-1&&(console.info("Typesetter: got text with \\r chars; normalizing to \\n"),a=a.replace(/\r\n/g,"\n").replace(/\r/g,"\n")),m=+m,M=+M,v=+v,y=y||"normal",P=+P,function({text:e,lang:i,fonts:n,style:r,weight:o,preResolvedFonts:a,unicodeFontsURL:s},l){const h=({chars:t,fonts:e})=>{let i,n;const r=[];for(let o=0;o<t.length;o++)t[o]!==n?(n=t[o],r.push(i={start:o,end:o,fontObj:e[t[o]]})):i.end=o;l(r)};a?h(a):t(e,h,{lang:i,fonts:n,style:r,weight:o,unicodeFontsURL:s})}({text:a,lang:d,style:f,weight:g,fonts:"string"==typeof u?[{src:u}]:u,unicodeFontsURL:T,preResolvedFonts:L},(t=>{z.fontLoad=h()-B;const u=isFinite(v);let d=null,p=null,g=null,f=null,T=null,L=null,R=null,V=null,N=0,Y=0,k="nowrap"!==x;const F=new Map,G=h();let U=P,X=0,j=new c;const H=[j];t.forEach((t=>{const{fontObj:e}=t,{ascender:i,descender:s,unitsPerEm:l,lineGap:h,capHeight:d,xHeight:p}=e;let g=F.get(e);if(!g){const t=m/l,n="normal"===y?(i-s+h)*t:y*m,r=(n-(i-s)*t)/2,o=Math.min(n,(i-s)*t),a=(i+s)/2*t+o/2;g={index:F.size,src:e.src,fontObj:e,fontSizeMult:t,unitsPerEm:l,ascender:i*t,descender:s*t,capHeight:d*t,xHeight:p*t,lineHeight:n,baseline:-r-i*t,caretTop:(i+s)/2*t+o/2,caretBottom:a-o},F.set(e,g)}const{fontSizeMult:f}=g,b=a.slice(t.start,t.end+1);let A,x;e.forEachGlyph(b,m,M,((e,i,s,l)=>{i+=X,l+=t.start,A=i,x=e;const h=a.charAt(l),d=e.advanceWidth*f,p=j.count;let y;if("isEmpty"in e||(e.isWhitespace=!!h&&new RegExp(r).test(h),e.canBreakAfter=!!h&&o.test(h),e.isEmpty=e.xMin===e.xMax||e.yMin===e.yMax||n.test(h)),e.isWhitespace||e.isEmpty||Y++,k&&u&&!e.isWhitespace&&i+d+U>v&&p){if(j.glyphAt(p-1).glyphObj.canBreakAfter)y=new c,U=-i;else for(let t=p;t--;){if(0===t&&"break-word"===S){y=new c,U=-i;break}if(j.glyphAt(t).glyphObj.canBreakAfter){y=j.splitAt(t+1);const e=y.glyphAt(0).x;U-=e;for(let t=y.count;t--;)y.glyphAt(t).x-=e;break}}y&&(j.isSoftWrapped=!0,j=y,H.push(j),N=v)}let b=j.glyphAt(j.count);b.glyphObj=e,b.x=i+U,b.y=s,b.width=d,b.charIndex=l,b.fontData=g,"\n"===h&&(j=new c,H.push(j),U=-(i+d+M*m)+P)})),X=A+x.advanceWidth*f+M*m}));let Z=0;H.forEach((t=>{let e=!0;for(let i=t.count;i--;){const n=t.glyphAt(i);e&&!n.glyphObj.isWhitespace&&(t.width=n.x+n.width,t.width>N&&(N=t.width),e=!1);let{lineHeight:r,capHeight:o,xHeight:a,baseline:s}=n.fontData;r>t.lineHeight&&(t.lineHeight=r);const l=s-t.baseline;l<0&&(t.baseline+=l,t.cap+=l,t.ex+=l),t.cap=Math.max(t.cap,t.baseline+o),t.ex=Math.max(t.ex,t.baseline+a)}t.baseline-=Z,t.cap-=Z,t.ex-=Z,Z+=t.lineHeight}));let W=0,Q=0;if(C&&("number"==typeof C?W=-C:"string"==typeof C&&(W=-N*("left"===C?0:"center"===C?.5:"right"===C?1:s(C)))),_&&("number"==typeof _?Q=-_:"string"==typeof _&&(Q="top"===_?0:"top-baseline"===_?-H[0].baseline:"top-cap"===_?-H[0].cap:"top-ex"===_?-H[0].ex:"middle"===_?Z/2:"bottom"===_?Z:"bottom-baseline"===_?H[H.length-1].baseline:s(_)*Z)),!w){const t=e.getEmbeddingLevels(a,b);d=new Uint16Array(Y),p=new Uint8Array(Y),g=new Float32Array(2*Y),f={},R=[i,i,-i,-i],V=[],D&&(L=new Float32Array(4*a.length)),O&&(T=new Uint8Array(3*Y));let n,r,o=0,s=-1,h=-1;if(H.forEach(((c,u)=>{let{count:m,width:M}=c;if(m>0){let u=0;for(let t=m;t--&&c.glyphAt(t).glyphObj.isWhitespace;)u++;let y=0,v=0;if("center"===A)y=(N-M)/2;else if("right"===A)y=N-M;else if("justify"===A&&c.isSoftWrapped){let t=0;for(let e=m-u;e--;)c.glyphAt(e).glyphObj.isWhitespace&&t++;v=(N-M)/t}if(v||y){let t=0;for(let e=0;e<m;e++){let i=c.glyphAt(e);const n=i.glyphObj;i.x+=y+t,0!==v&&n.isWhitespace&&e<m-u&&(t+=v,i.width+=v)}}const b=e.getReorderSegments(a,t,c.glyphAt(0).charIndex,c.glyphAt(c.count-1).charIndex);for(let t=0;t<b.length;t++){const[e,i]=b[t];let n=1/0,r=-1/0;for(let t=0;t<m;t++)if(c.glyphAt(t).charIndex>=e){let e=t,o=t;for(;o<m;o++){let t=c.glyphAt(o);if(t.charIndex>i)break;o<m-u&&(n=Math.min(n,t.x),r=Math.max(r,t.x+t.width))}for(let t=e;t<o;t++){const e=c.glyphAt(t);e.x=r-(e.x+e.width-n)}break}}let P;const x=t=>P=t;for(let u=0;u<m;u++){const m=c.glyphAt(u);P=m.glyphObj;const M=P.index,y=1&t.levels[m.charIndex];if(y){const t=e.getMirroredCharacter(a[m.charIndex]);t&&m.fontData.fontObj.forEachGlyph(t,0,0,x)}if(D){const{charIndex:t,fontData:e}=m,i=m.x+W,n=m.x+m.width+W;L[4*t]=y?n:i,L[4*t+1]=y?i:n,L[4*t+2]=c.baseline+e.caretBottom+Q,L[4*t+3]=c.baseline+e.caretTop+Q;const r=t-s;r>1&&l(L,s,r),s=t}if(O){const{charIndex:t}=m;for(;t>h;)h++,O.hasOwnProperty(h)&&(r=O[h])}if(!P.isWhitespace&&!P.isEmpty){const t=o++,{fontSizeMult:e,src:a,index:s}=m.fontData,l=f[a]||(f[a]={});l[M]||(l[M]={path:P.path,pathBounds:[P.xMin,P.yMin,P.xMax,P.yMax]});const h=m.x+W,u=m.y+c.baseline+Q;g[2*t]=h,g[2*t+1]=u;const y=h+P.xMin*e,v=u+P.yMin*e,b=h+P.xMax*e,A=u+P.yMax*e;y<R[0]&&(R[0]=y),v<R[1]&&(R[1]=v),b>R[2]&&(R[2]=b),A>R[3]&&(R[3]=A),t%I==0&&(n={start:t,end:t,rect:[i,i,-i,-i]},V.push(n)),n.end++;const x=n.rect;if(y<x[0]&&(x[0]=y),v<x[1]&&(x[1]=v),b>x[2]&&(x[2]=b),A>x[3]&&(x[3]=A),d[t]=M,p[t]=s,O){const e=3*t;T[e]=r>>16&255,T[e+1]=r>>8&255,T[e+2]=255&r}}}}})),L){const t=a.length-s;t>1&&l(L,s,t)}}const q=[];F.forEach((({index:t,src:e,unitsPerEm:i,ascender:n,descender:r,lineHeight:o,capHeight:a,xHeight:s})=>{q[t]={src:e,unitsPerEm:i,ascender:n,descender:r,lineHeight:o,capHeight:a,xHeight:s}})),z.typesetting=h()-G,E({glyphIds:d,glyphFontIndices:p,glyphPositions:g,glyphData:f,fontData:q,caretPositions:L,glyphColors:T,chunkedBounds:V,fontSize:m,topBaseline:Q+H[0].baseline,blockBounds:[W,Q-Z,W+N,Q],visibleBounds:R,timings:z})}))}function s(t){let e=t.match(/^([\d.]+)%$/),i=e?parseFloat(e[1]):NaN;return isNaN(i)?0:i/100}function l(t,e,i){const n=t[4*e],r=t[4*e+1],o=t[4*e+2],a=t[4*e+3],s=(r-n)/i;for(let r=0;r<i;r++){const i=4*(e+r);t[i]=n+s*r,t[i+1]=n+s*(r+1),t[i+2]=o,t[i+3]=a}}function h(){return(self.performance||Date).now()}function c(){this.data=[]}const u=["glyphObj","x","y","width","charIndex","fontData"];return c.prototype={width:0,lineHeight:0,baseline:0,cap:0,ex:0,isSoftWrapped:!1,get count(){return Math.ceil(this.data.length/u.length)},glyphAt(t){let e=c.flyweight;return e.data=this.data,e.index=t,e},splitAt(t){let e=new c;return e.data=this.data.splice(t*u.length),e}},c.flyweight=u.reduce(((t,e,i,n)=>(Object.defineProperty(t,e,{get(){return this.data[this.index*u.length+i]},set(t){this.data[this.index*u.length+i]=t}}),t)),{data:null,index:0}),{typeset:a,measure:function(t,e){a({...t,metricsOnly:!0},(t=>{const[i,n,r,o]=t.blockBounds;e({width:r-i,height:o-n})}))}}}
)}
)